{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highstock JS v11.4.7 (2024-08-14)\n *\n * Indicator series type for Highcharts Stock\n *\n * (c) 2010-2024 Sebastian Bochan\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/indicators/ichimoku-kinko-hyo', ['highcharts', 'highcharts/modules/stock'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                Highcharts.win.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Stock/Indicators/IKH/IKHIndicator.js', [_modules['Extensions/DataGrouping/ApproximationRegistry.js'], _modules['Core/Color/Color.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (ApproximationRegistry, Color, SeriesRegistry, U) {\n        /* *\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { parse: color } = Color;\n        const { sma: SMAIndicator } = SeriesRegistry.seriesTypes;\n        const { defined, extend, isArray, isNumber, getClosestDistance, merge, objectEach } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function maxHigh(arr) {\n            return arr.reduce(function (max, res) {\n                return Math.max(max, res[1]);\n            }, -Infinity);\n        }\n        /**\n         * @private\n         */\n        function minLow(arr) {\n            return arr.reduce(function (min, res) {\n                return Math.min(min, res[2]);\n            }, Infinity);\n        }\n        /**\n         * @private\n         */\n        function highlowLevel(arr) {\n            return {\n                high: maxHigh(arr),\n                low: minLow(arr)\n            };\n        }\n        /**\n         * Check two lines intersection (line a1-a2 and b1-b2)\n         * Source: https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection\n         * @private\n         */\n        function checkLineIntersection(a1, a2, b1, b2) {\n            if (a1 && a2 && b1 && b2) {\n                const saX = a2.plotX - a1.plotX, // Auxiliary section a2-a1 X\n                saY = a2.plotY - a1.plotY, // Auxiliary section a2-a1 Y\n                sbX = b2.plotX - b1.plotX, // Auxiliary section b2-b1 X\n                sbY = b2.plotY - b1.plotY, // Auxiliary section b2-b1 Y\n                sabX = a1.plotX - b1.plotX, // Auxiliary section a1-b1 X\n                sabY = a1.plotY - b1.plotY, // Auxiliary section a1-b1 Y\n                // First degree BÃ©zier parameters\n                u = (-saY * sabX + saX * sabY) / (-sbX * saY + saX * sbY), t = (sbX * sabY - sbY * sabX) / (-sbX * saY + saX * sbY);\n                if (u >= 0 && u <= 1 && t >= 0 && t <= 1) {\n                    return {\n                        plotX: a1.plotX + t * saX,\n                        plotY: a1.plotY + t * saY\n                    };\n                }\n            }\n        }\n        /**\n         * Parameter opt (indicator options object) include indicator, points,\n         * nextPoints, color, options, gappedExtend and graph properties\n         * @private\n         */\n        function drawSenkouSpan(opt) {\n            const indicator = opt.indicator;\n            indicator.points = opt.points;\n            indicator.nextPoints = opt.nextPoints;\n            indicator.color = opt.color;\n            indicator.options = merge(opt.options.senkouSpan.styles, opt.gap);\n            indicator.graph = opt.graph;\n            indicator.fillGraph = true;\n            SeriesRegistry.seriesTypes.sma.prototype.drawGraph.call(indicator);\n        }\n        /**\n         * Data integrity in Ichimoku is different than default 'averages':\n         * Point: [undefined, value, value, ...] is correct\n         * Point: [undefined, undefined, undefined, ...] is incorrect\n         * @private\n         */\n        function ichimokuAverages() {\n            const ret = [];\n            let isEmptyRange;\n            [].forEach.call(arguments, function (arr, i) {\n                ret.push(ApproximationRegistry.average(arr));\n                isEmptyRange = !isEmptyRange && typeof ret[i] === 'undefined';\n            });\n            // Return undefined when first elem. is undefined and let\n            // sum method handle null (#7377)\n            return isEmptyRange ? void 0 : ret;\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The IKH series type.\n         *\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.ikh\n         *\n         * @augments Highcharts.Series\n         */\n        class IKHIndicator extends SMAIndicator {\n            constructor() {\n                /* *\n                 *\n                 *  Static Properties\n                 *\n                 * */\n                super(...arguments);\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                this.data = [];\n                this.options = {};\n                this.points = [];\n                this.graphCollection = [];\n            }\n            /* *\n             *\n             * Functions\n             *\n             * */\n            init() {\n                super.init.apply(this, arguments);\n                // Set default color for lines:\n                this.options = merge({\n                    tenkanLine: {\n                        styles: {\n                            lineColor: this.color\n                        }\n                    },\n                    kijunLine: {\n                        styles: {\n                            lineColor: this.color\n                        }\n                    },\n                    chikouLine: {\n                        styles: {\n                            lineColor: this.color\n                        }\n                    },\n                    senkouSpanA: {\n                        styles: {\n                            lineColor: this.color,\n                            fill: color(this.color).setOpacity(0.5).get()\n                        }\n                    },\n                    senkouSpanB: {\n                        styles: {\n                            lineColor: this.color,\n                            fill: color(this.color).setOpacity(0.5).get()\n                        }\n                    },\n                    senkouSpan: {\n                        styles: {\n                            fill: color(this.color).setOpacity(0.2).get()\n                        }\n                    }\n                }, this.options);\n            }\n            toYData(point) {\n                return [\n                    point.tenkanSen,\n                    point.kijunSen,\n                    point.chikouSpan,\n                    point.senkouSpanA,\n                    point.senkouSpanB\n                ];\n            }\n            translate() {\n                const indicator = this;\n                SeriesRegistry.seriesTypes.sma.prototype.translate.apply(indicator);\n                for (const point of indicator.points) {\n                    for (const key of indicator.pointArrayMap) {\n                        const pointValue = point[key];\n                        if (isNumber(pointValue)) {\n                            point['plot' + key] = indicator.yAxis.toPixels(pointValue, true);\n                            // Add extra parameters for support tooltip in moved\n                            // lines\n                            point.plotY = point['plot' + key];\n                            point.tooltipPos = [\n                                point.plotX,\n                                point['plot' + key]\n                            ];\n                            point.isNull = false;\n                        }\n                    }\n                }\n            }\n            drawGraph() {\n                const indicator = this, mainLinePoints = indicator.points, mainLineOptions = indicator.options, mainLinePath = indicator.graph, mainColor = indicator.color, gappedExtend = {\n                    options: {\n                        gapSize: mainLineOptions.gapSize\n                    }\n                }, pointArrayMapLength = indicator.pointArrayMap.length, allIchimokuPoints = [\n                    [],\n                    [],\n                    [],\n                    [],\n                    [],\n                    []\n                ], ikhMap = {\n                    tenkanLine: allIchimokuPoints[0],\n                    kijunLine: allIchimokuPoints[1],\n                    chikouLine: allIchimokuPoints[2],\n                    senkouSpanA: allIchimokuPoints[3],\n                    senkouSpanB: allIchimokuPoints[4],\n                    senkouSpan: allIchimokuPoints[5]\n                }, intersectIndexColl = [], senkouSpanOptions = indicator\n                    .options.senkouSpan, color = senkouSpanOptions.color ||\n                    senkouSpanOptions.styles.fill, negativeColor = senkouSpanOptions.negativeColor, \n                // Points to create color and negativeColor senkouSpan\n                points = [\n                    [], // Points color\n                    [] // Points negative color\n                ], \n                // For span, we need an access to the next points, used in\n                // getGraphPath()\n                nextPoints = [\n                    [], // Next points color\n                    [] // Next points negative color\n                ];\n                let pointsLength = mainLinePoints.length, lineIndex = 0, position, point, i, startIntersect, endIntersect, sectionPoints, sectionNextPoints, pointsPlotYSum, nextPointsPlotYSum, senkouSpanTempColor, concatArrIndex, j, k;\n                indicator.ikhMap = ikhMap;\n                // Generate points for all lines and spans lines:\n                while (pointsLength--) {\n                    point = mainLinePoints[pointsLength];\n                    for (i = 0; i < pointArrayMapLength; i++) {\n                        position = indicator.pointArrayMap[i];\n                        if (defined(point[position])) {\n                            allIchimokuPoints[i].push({\n                                plotX: point.plotX,\n                                plotY: point['plot' + position],\n                                isNull: false\n                            });\n                        }\n                    }\n                    if (negativeColor && pointsLength !== mainLinePoints.length - 1) {\n                        // Check if lines intersect\n                        const index = ikhMap.senkouSpanB.length - 1, intersect = checkLineIntersection(ikhMap.senkouSpanA[index - 1], ikhMap.senkouSpanA[index], ikhMap.senkouSpanB[index - 1], ikhMap.senkouSpanB[index]);\n                        if (intersect) {\n                            const intersectPointObj = {\n                                plotX: intersect.plotX,\n                                plotY: intersect.plotY,\n                                isNull: false,\n                                intersectPoint: true\n                            };\n                            // Add intersect point to ichimoku points collection\n                            // Create senkouSpan sections\n                            ikhMap.senkouSpanA.splice(index, 0, intersectPointObj);\n                            ikhMap.senkouSpanB.splice(index, 0, intersectPointObj);\n                            intersectIndexColl.push(index);\n                        }\n                    }\n                }\n                // Modify options and generate lines:\n                objectEach(ikhMap, (values, lineName) => {\n                    if (mainLineOptions[lineName] &&\n                        lineName !== 'senkouSpan') {\n                        // First line is rendered by default option\n                        indicator.points = allIchimokuPoints[lineIndex];\n                        indicator.options = merge(mainLineOptions[lineName].styles, gappedExtend);\n                        indicator.graph = indicator['graph' + lineName];\n                        indicator.fillGraph = false;\n                        indicator.color = mainColor;\n                        SeriesRegistry.seriesTypes.sma.prototype.drawGraph.call(indicator);\n                        // Now save line\n                        indicator['graph' + lineName] = indicator.graph;\n                    }\n                    lineIndex++;\n                });\n                // Generate senkouSpan area:\n                // If graphCollection exist then remove svg\n                // element and indicator property\n                if (indicator.graphCollection) {\n                    for (const graphName of indicator.graphCollection) {\n                        indicator[graphName].destroy();\n                        delete indicator[graphName];\n                    }\n                }\n                // Clean graphCollection or initialize it\n                indicator.graphCollection = [];\n                // When user set negativeColor property\n                if (negativeColor && ikhMap.senkouSpanA[0] && ikhMap.senkouSpanB[0]) {\n                    // Add first and last point to senkouSpan area sections\n                    intersectIndexColl.unshift(0);\n                    intersectIndexColl.push(ikhMap.senkouSpanA.length - 1);\n                    // Populate points and nextPoints arrays\n                    for (j = 0; j < intersectIndexColl.length - 1; j++) {\n                        startIntersect = intersectIndexColl[j];\n                        endIntersect = intersectIndexColl[j + 1];\n                        sectionPoints = ikhMap.senkouSpanB.slice(startIntersect, endIntersect + 1);\n                        sectionNextPoints = ikhMap.senkouSpanA.slice(startIntersect, endIntersect + 1);\n                        // Add points to color or negativeColor arrays\n                        // Check the middle point (if exist)\n                        if (Math.floor(sectionPoints.length / 2) >= 1) {\n                            const x = Math.floor(sectionPoints.length / 2);\n                            // When middle points has equal values\n                            // Compare all points plotY value sum\n                            if (sectionPoints[x].plotY === sectionNextPoints[x].plotY) {\n                                pointsPlotYSum = 0;\n                                nextPointsPlotYSum = 0;\n                                for (k = 0; k < sectionPoints.length; k++) {\n                                    pointsPlotYSum += sectionPoints[k].plotY;\n                                    nextPointsPlotYSum += sectionNextPoints[k].plotY;\n                                }\n                                concatArrIndex =\n                                    pointsPlotYSum > nextPointsPlotYSum ? 0 : 1;\n                                points[concatArrIndex] = points[concatArrIndex].concat(sectionPoints);\n                                nextPoints[concatArrIndex] = nextPoints[concatArrIndex].concat(sectionNextPoints);\n                            }\n                            else {\n                                // Compare middle point of the section\n                                concatArrIndex = (sectionPoints[x].plotY > sectionNextPoints[x].plotY) ? 0 : 1;\n                                points[concatArrIndex] = points[concatArrIndex].concat(sectionPoints);\n                                nextPoints[concatArrIndex] = nextPoints[concatArrIndex].concat(sectionNextPoints);\n                            }\n                        }\n                        else {\n                            // Compare first point of the section\n                            concatArrIndex = (sectionPoints[0].plotY > sectionNextPoints[0].plotY) ? 0 : 1;\n                            points[concatArrIndex] = points[concatArrIndex].concat(sectionPoints);\n                            nextPoints[concatArrIndex] = nextPoints[concatArrIndex].concat(sectionNextPoints);\n                        }\n                    }\n                    // Render color and negativeColor paths\n                    ['graphsenkouSpanColor', 'graphsenkouSpanNegativeColor'].forEach(function (areaName, i) {\n                        if (points[i].length && nextPoints[i].length) {\n                            senkouSpanTempColor = i === 0 ? color : negativeColor;\n                            drawSenkouSpan({\n                                indicator: indicator,\n                                points: points[i],\n                                nextPoints: nextPoints[i],\n                                color: senkouSpanTempColor,\n                                options: mainLineOptions,\n                                gap: gappedExtend,\n                                graph: indicator[areaName]\n                            });\n                            // Now save line\n                            indicator[areaName] = indicator.graph;\n                            indicator.graphCollection.push(areaName);\n                        }\n                    });\n                }\n                else {\n                    // When user set only senkouSpan style.fill property\n                    drawSenkouSpan({\n                        indicator: indicator,\n                        points: ikhMap.senkouSpanB,\n                        nextPoints: ikhMap.senkouSpanA,\n                        color: color,\n                        options: mainLineOptions,\n                        gap: gappedExtend,\n                        graph: indicator.graphsenkouSpan\n                    });\n                    // Now save line\n                    indicator.graphsenkouSpan = indicator.graph;\n                }\n                // Clean temporary properties:\n                delete indicator.nextPoints;\n                delete indicator.fillGraph;\n                // Restore options and draw the Tenkan line:\n                indicator.points = mainLinePoints;\n                indicator.options = mainLineOptions;\n                indicator.graph = mainLinePath;\n                indicator.color = mainColor;\n            }\n            getGraphPath(points) {\n                const indicator = this;\n                let path = [], spanA, spanAarr = [];\n                points = points || this.points;\n                // Render Senkou Span\n                if (indicator.fillGraph && indicator.nextPoints) {\n                    spanA = SeriesRegistry.seriesTypes.sma.prototype.getGraphPath.call(indicator, \n                    // Reverse points, so Senkou Span A will start from the end:\n                    indicator.nextPoints);\n                    if (spanA && spanA.length) {\n                        spanA[0][0] = 'L';\n                        path = SeriesRegistry.seriesTypes.sma.prototype.getGraphPath\n                            .call(indicator, points);\n                        spanAarr = spanA.slice(0, path.length);\n                        for (let i = spanAarr.length - 1; i >= 0; i--) {\n                            path.push(spanAarr[i]);\n                        }\n                    }\n                }\n                else {\n                    path = SeriesRegistry.seriesTypes.sma.prototype.getGraphPath\n                        .apply(indicator, arguments);\n                }\n                return path;\n            }\n            getValues(series, params) {\n                const period = params.period, periodTenkan = params.periodTenkan, periodSenkouSpanB = params.periodSenkouSpanB, xVal = series.xData, yVal = series.yData, xAxis = series.xAxis, yValLen = (yVal && yVal.length) || 0, closestPointRange = getClosestDistance(xAxis.series.map((s) => s.xData || [])), IKH = [], xData = [];\n                let date, slicedTSY, slicedKSY, slicedSSBY, pointTS, pointKS, pointSSB, i, TS, KS, CS, SSA, SSB;\n                // Ikh requires close value\n                if (xVal.length <= period ||\n                    !isArray(yVal[0]) ||\n                    yVal[0].length !== 4) {\n                    return;\n                }\n                // Add timestamps at the beginning\n                const dateStart = xVal[0] - period * closestPointRange;\n                for (i = 0; i < period; i++) {\n                    xData.push(dateStart + i * closestPointRange);\n                }\n                for (i = 0; i < yValLen; i++) {\n                    // Tenkan Sen\n                    if (i >= periodTenkan) {\n                        slicedTSY = yVal.slice(i - periodTenkan, i);\n                        pointTS = highlowLevel(slicedTSY);\n                        TS = (pointTS.high + pointTS.low) / 2;\n                    }\n                    if (i >= period) {\n                        slicedKSY = yVal.slice(i - period, i);\n                        pointKS = highlowLevel(slicedKSY);\n                        KS = (pointKS.high + pointKS.low) / 2;\n                        SSA = (TS + KS) / 2;\n                    }\n                    if (i >= periodSenkouSpanB) {\n                        slicedSSBY = yVal.slice(i - periodSenkouSpanB, i);\n                        pointSSB = highlowLevel(slicedSSBY);\n                        SSB = (pointSSB.high + pointSSB.low) / 2;\n                    }\n                    CS = yVal[i][3];\n                    date = xVal[i];\n                    if (typeof IKH[i] === 'undefined') {\n                        IKH[i] = [];\n                    }\n                    if (typeof IKH[i + period - 1] === 'undefined') {\n                        IKH[i + period - 1] = [];\n                    }\n                    IKH[i + period - 1][0] = TS;\n                    IKH[i + period - 1][1] = KS;\n                    IKH[i + period - 1][2] = void 0;\n                    if (typeof IKH[i + 1] === 'undefined') {\n                        IKH[i + 1] = [];\n                    }\n                    IKH[i + 1][2] = CS;\n                    if (i <= period) {\n                        IKH[i + period - 1][3] = void 0;\n                        IKH[i + period - 1][4] = void 0;\n                    }\n                    if (typeof IKH[i + 2 * period - 2] === 'undefined') {\n                        IKH[i + 2 * period - 2] = [];\n                    }\n                    IKH[i + 2 * period - 2][3] = SSA;\n                    IKH[i + 2 * period - 2][4] = SSB;\n                    xData.push(date);\n                }\n                // Add timestamps for further points\n                for (i = 1; i <= period; i++) {\n                    xData.push(date + i * closestPointRange);\n                }\n                return {\n                    values: IKH,\n                    xData: xData,\n                    yData: IKH\n                };\n            }\n        }\n        /**\n         * Ichimoku Kinko Hyo (IKH). This series requires `linkedTo` option to be\n         * set.\n         *\n         * @sample stock/indicators/ichimoku-kinko-hyo\n         *         Ichimoku Kinko Hyo indicator\n         *\n         * @extends      plotOptions.sma\n         * @since        6.0.0\n         * @excluding    allAreas, colorAxis, compare, compareBase, joinBy, keys,\n         *               navigatorOptions, pointInterval, pointIntervalUnit,\n         *               pointPlacement, pointRange, pointStart, showInNavigator,\n         *               stacking\n         * @product      highstock\n         * @requires     stock/indicators/indicators\n         * @requires     stock/indicators/ichimoku-kinko-hyo\n         * @optionparent plotOptions.ikh\n         */\n        IKHIndicator.defaultOptions = merge(SMAIndicator.defaultOptions, {\n            /**\n             * @excluding index\n             */\n            params: {\n                index: void 0, // Unused index, do not inherit (#15362)\n                period: 26,\n                /**\n                 * The base period for Tenkan calculations.\n                 */\n                periodTenkan: 9,\n                /**\n                 * The base period for Senkou Span B calculations\n                 */\n                periodSenkouSpanB: 52\n            },\n            marker: {\n                enabled: false\n            },\n            tooltip: {\n                pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> <b> {series.name}</b><br/>' +\n                    'TENKAN SEN: {point.tenkanSen:.3f}<br/>' +\n                    'KIJUN SEN: {point.kijunSen:.3f}<br/>' +\n                    'CHIKOU SPAN: {point.chikouSpan:.3f}<br/>' +\n                    'SENKOU SPAN A: {point.senkouSpanA:.3f}<br/>' +\n                    'SENKOU SPAN B: {point.senkouSpanB:.3f}<br/>'\n            },\n            /**\n             * The styles for Tenkan line\n             */\n            tenkanLine: {\n                styles: {\n                    /**\n                     * Pixel width of the line.\n                     */\n                    lineWidth: 1,\n                    /**\n                     * Color of the line.\n                     *\n                     * @type {Highcharts.ColorString}\n                     */\n                    lineColor: void 0\n                }\n            },\n            /**\n             * The styles for Kijun line\n             */\n            kijunLine: {\n                styles: {\n                    /**\n                     * Pixel width of the line.\n                     */\n                    lineWidth: 1,\n                    /**\n                     * Color of the line.\n                     *\n                     * @type {Highcharts.ColorString}\n                     */\n                    lineColor: void 0\n                }\n            },\n            /**\n             * The styles for Chikou line\n             */\n            chikouLine: {\n                styles: {\n                    /**\n                     * Pixel width of the line.\n                     */\n                    lineWidth: 1,\n                    /**\n                     * Color of the line.\n                     *\n                     * @type {Highcharts.ColorString}\n                     */\n                    lineColor: void 0\n                }\n            },\n            /**\n             * The styles for Senkou Span A line\n             */\n            senkouSpanA: {\n                styles: {\n                    /**\n                     * Pixel width of the line.\n                     */\n                    lineWidth: 1,\n                    /**\n                     * Color of the line.\n                     *\n                     * @type {Highcharts.ColorString}\n                     */\n                    lineColor: void 0\n                }\n            },\n            /**\n             * The styles for Senkou Span B line\n             */\n            senkouSpanB: {\n                styles: {\n                    /**\n                     * Pixel width of the line.\n                     */\n                    lineWidth: 1,\n                    /**\n                     * Color of the line.\n                     *\n                     * @type {Highcharts.ColorString}\n                     */\n                    lineColor: void 0\n                }\n            },\n            /**\n             * The styles for area between Senkou Span A and B.\n             */\n            senkouSpan: {\n                /**\n                 * Color of the area between Senkou Span A and B,\n                 * when Senkou Span A is above Senkou Span B. Note that if\n                 * a `style.fill` is defined, the `color` takes precedence and\n                 * the `style.fill` is ignored.\n                 *\n                 * @see [senkouSpan.styles.fill](#series.ikh.senkouSpan.styles.fill)\n                 *\n                 * @sample stock/indicators/ichimoku-kinko-hyo\n                 *         Ichimoku Kinko Hyo color\n                 *\n                 * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                 * @since     7.0.0\n                 * @apioption plotOptions.ikh.senkouSpan.color\n                 */\n                /**\n                 * Color of the area between Senkou Span A and B,\n                 * when Senkou Span A is under Senkou Span B.\n                 *\n                 * @sample stock/indicators/ikh-negative-color\n                 *         Ichimoku Kinko Hyo negativeColor\n                 *\n                 * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                 * @since     7.0.0\n                 * @apioption plotOptions.ikh.senkouSpan.negativeColor\n                 */\n                styles: {\n                    /**\n                     * Color of the area between Senkou Span A and B.\n                     *\n                     * @deprecated\n                     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                     */\n                    fill: 'rgba(255, 0, 0, 0.5)'\n                }\n            },\n            dataGrouping: {\n                approximation: 'ichimoku-averages'\n            }\n        });\n        extend(IKHIndicator.prototype, {\n            pointArrayMap: [\n                'tenkanSen',\n                'kijunSen',\n                'chikouSpan',\n                'senkouSpanA',\n                'senkouSpanB'\n            ],\n            pointValKey: 'tenkanSen',\n            nameComponents: ['periodSenkouSpanB', 'period', 'periodTenkan']\n        });\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        ApproximationRegistry['ichimoku-averages'] = ichimokuAverages;\n        SeriesRegistry.registerSeriesType('ikh', IKHIndicator);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * A `IKH` series. If the [type](#series.ikh.type) option is not\n         * specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.ikh\n         * @since     6.0.0\n         * @product   highstock\n         * @excluding dataParser, dataURL\n         * @requires  stock/indicators/indicators\n         * @requires  stock/indicators/ichimoku-kinko-hyo\n         * @apioption series.ikh\n         */\n        (''); // Add doclet above to transpiled file\n\n        return IKHIndicator;\n    });\n    _registerModule(_modules, 'masters/indicators/ichimoku-kinko-hyo.src.js', [_modules['Core/Globals.js']], function (Highcharts) {\n\n\n        return Highcharts;\n    });\n}));\n"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","win","dispatchEvent","detail","ApproximationRegistry","Color","SeriesRegistry","U","parse","color","sma","SMAIndicator","seriesTypes","defined","extend","isArray","isNumber","getClosestDistance","merge","objectEach","highlowLevel","arr","high","reduce","max","res","Math","Infinity","low","min","drawSenkouSpan","opt","indicator","points","nextPoints","options","senkouSpan","styles","gap","graph","fillGraph","prototype","drawGraph","call","IKHIndicator","constructor","arguments","data","graphCollection","init","tenkanLine","lineColor","kijunLine","chikouLine","senkouSpanA","fill","setOpacity","get","senkouSpanB","toYData","point","tenkanSen","kijunSen","chikouSpan","translate","key","pointArrayMap","pointValue","yAxis","toPixels","plotY","tooltipPos","plotX","isNull","mainLinePoints","mainLineOptions","mainLinePath","mainColor","gappedExtend","gapSize","pointArrayMapLength","length","allIchimokuPoints","ikhMap","intersectIndexColl","senkouSpanOptions","negativeColor","pointsLength","lineIndex","position","i","startIntersect","endIntersect","sectionPoints","sectionNextPoints","pointsPlotYSum","nextPointsPlotYSum","senkouSpanTempColor","concatArrIndex","j","k","push","index","intersect","checkLineIntersection","a1","a2","b1","b2","saX","saY","sbX","sbY","sabX","sabY","u","t","intersectPointObj","intersectPoint","splice","values","lineName","graphName","destroy","unshift","slice","floor","x","concat","forEach","areaName","graphsenkouSpan","getGraphPath","spanA","spanAarr","getValues","series","params","date","pointTS","pointKS","pointSSB","TS","KS","CS","SSA","SSB","period","periodTenkan","periodSenkouSpanB","xVal","xData","yVal","yData","xAxis","yValLen","closestPointRange","map","s","IKH","dateStart","defaultOptions","marker","enabled","tooltip","pointFormat","lineWidth","dataGrouping","approximation","pointValKey","nameComponents","isEmptyRange","ret","average","registerSeriesType"],"mappings":"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"}